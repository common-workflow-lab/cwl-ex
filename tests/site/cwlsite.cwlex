def tool makerdfs(schema File, target_path string) {
  python -mschema_salad --print-rdfs $(inputs.schema) > $(inputs.target_path)
  rdfs = File(inputs.target_path)
  targetdir = string(inputs.target_path.match(/^([^/]+)\/[^/]/)[1])
}

def tool makecontext(schema File, target_path string) {
  python -mschema_salad --print-jsonld-context $(inputs.schema) > $(inputs.target_path)
  jsonld_context = File(inputs.target_path)
  targetdir = string(inputs.target_path.match(/^([^/]+)\/[^/]/)[1])
}

def tool inheritance(schema File, target_path string) {
  sh > $(inputs.target_path) <<<
schema-salad-tool --print-inheritance-dot "$(inputs.schema.path)" | dot -Tsvg
>>>
  svg = File(inputs.target_path)
  targetdir = string(inputs.target_path.match(/^([^/]+)\/[^/]/)[1])
}

def tool makedoc(
  source File,
  renderlist? string[],
  redirect? string[],
  brand string,
  brandlink string,
  target string,
  primtype? string,
  extra File)
{
  schema-salad-doc $(inputs.source) > $(inputs.target)
    ? --only renderlist
    ? --redirect for each in redirect
    ? --brand brand
    ? --brandlink brandlink
    ? --primtype primtype
  html = File(inputs.target)
  targetdir = string{
    var m = inputs.target.match(/^([^/]+)\/[^/]/);
    if (m)
       return m[1];
    else
       return "";
  }
  extra_out = extra
}

def workflow main(
  render struct {
    source File,
    renderlist? string[],
    redirect? string[],
    target string,
    brandlink string,
    brandimg string,
    primtype? string,
    extra File
  }[],
  schemas struct {
    schema_in File,
    context_target string,
    rdfs_target string,
    graph_target string
  }[],
  brandimg File
) {

  (rdfs, rdfstargetdir=targetdir) = run workflow (schemas) {
    (rdfs, targetdir) = makerdfs(schema=$(inputs.schema.schema_in),
                             target_path=$(inputs.schema.rdfs_target)
			     ) for each schema in schemas
    return (rdfs, targetdir)
  }

  (jsonld_context, contexttargetdir=targetdir) = makecontext(schema=$(inputs.schema.schema_in),
                             target_path=$(inputs.schema.context_target)
			     ) for each schema in schemas

  (svg, svgtargetdir=targetdir) = inheritance(schema=$(inputs.schema.schema_in),
                             target_path=$(inputs.schema.graph_target)
			     ) for each schema in schemas

  (html, htmltargetdir=targetdir, extra_out) = makedoc(
     source=$(inputs.rdr.source),
     target=$(inputs.rdr.target),
     rdrlist=$(inputs.rdr.renderlist),
     redirect=$(inputs.rdr.redirect),
     brandlink=$(inputs.rdr.brandlink),
     brand=$(inputs.rdr.brandimg),
     primtype=$(inputs.rdr.primtype),
     extra=$(inputs.rdr.extra)) for each rdr in render

  empty = ""

  doc_out = File{
    var primary = inputs.primary[0];
    var secondary = inputs.secondary.slice(1);
    var dirs = inputs.dirs.slice(1);
    primary.secondaryFiles = [];
    for (var i = 0; i < secondary.length; i++) {
      var k = secondary[i];
      if (dirs[i] != "") {
        primary.secondaryFiles.push({
            class: "Directory",
            basename: dirs[i],
            listing: [k]
        });
      } else {
        primary.secondaryFiles.push(k);
      }
    }
    return primary;
  }(primary=html,
    secondary=merge_flattened(html, rdfs, jsonld_context,
                              brandimg, extra_out, svg),
    dirs=merge_flattened(htmltargetdir, rdfstargetdir, contexttargetdir,
                         empty, htmltargetdir, svgtargetdir))

  report = run tool (doc_out) {
    checklink -X(http.*|mailto:.*) -q $(inputs.doc_out) > linkchecker-report.txt
    report = File("linkchecker-report.txt")
  }

  return (doc_out, report)
}